## 模块: Java 异常处理机制

Java 的异常处理机制是一种强大的错误处理方式，它使得程序的主要逻辑和错误处理逻辑可以分离开来。

### `Throwable` 类层次结构

所有异常和错误的根类是 `java.lang.Throwable`。

```
      java.lang.Throwable
        /             \
java.lang.Error   java.lang.Exception
                       /           \
      Checked Exception     Unchecked Exception (RuntimeException)
```

#### 1. `Error`
- **定义**: 表示严重的、程序无法处理的系统级错误，例如 `OutOfMemoryError`、`StackOverflowError`。
- **特点**: `Error` 通常是不可恢复的，应用程序不应该（也无法）捕获和处理它们。

#### 2. `Exception`
- **定义**: 表示程序本身可以处理的异常情况。它分为两类：Checked Exception 和 Unchecked Exception。

##### a. `Checked Exception` (受检异常)
- **定义**: 除了 `RuntimeException` 及其子类之外的所有 `Exception`。
- **特点**:
    - **强制处理**: Java 编译器会强制要求你必须处理（通过 `try-catch` 捕获）或声明抛出（通过 `throws` 关键字）这类异常。
    - **场景**: 通常表示可恢复的、由外部因素引起的异常，如 `IOException`、`SQLException`。

##### b. `Unchecked Exception` (非受检异常)
- **定义**: `RuntimeException` 及其所有子类。
- **特点**:
    - **非强制处理**: 编译器不强制要求处理。
    - **场景**: 通常表示程序中的逻辑错误，如 `NullPointerException`、`IllegalArgumentException`、`IndexOutOfBoundsException`。这些异常本应在编码阶段通过逻辑判断来避免。

---

### 核心关键字

- **`try`**: 包含可能抛出异常的代码块。
- **`catch`**: 捕获并处理 `try` 块中抛出的特定类型的异常。可以有多个 `catch` 块。
- **`finally`**: 无论是否发生异常，`finally` 块中的代码总会被执行（除了JVM退出的情况）。主要用于资源释放。
- **`throw`**: 手动抛出一个异常对象。
- **`throws`**: 在方法签名中声明该方法可能抛出的异常类型，将处理责任交给调用者。

---

### `try-with-resources` (Java 7+)

- **定义**: 一种语法糖，用于自动关闭实现了 `java.lang.AutoCloseable` 或 `java.io.Closeable` 接口的资源。
- **优点**:
    - **代码简洁**: 无需手动编写 `finally` 块来关闭资源。
    - **避免资源泄漏**: 编译器会自动生成关闭资源的代码，比手动管理更安全。
- **示例**:
  ```java
  try (FileInputStream fis = new FileInputStream("file.txt")) {
      // ... use the resource ...
  } catch (IOException e) {
      // ... handle exception ...
  }
  // fis is automatically closed here
  ```

### 释放资源
“报错了”并不会自动帮你把所有资源都释放掉，只会做一件事：回收 Java 堆里的对象内存。而很多我们说的“资源”根本不在堆里，所以需要自己关。

常见的操作系统 / 外部资源：

- 文件描述符（打开文件、Socket 都要占一个 fd）
- 网络连接（TCP 连接、HTTP 连接）
- 数据库连接、游标、会话
- 线程、进程、锁、信号量
- GPU 上下文、native 内存块等

它们有几个共同点：
1.数量很有限
2.操作系统会限制“一个进程最多能打开多少个文件/Socket”
3.数据库连接池有最大连接数
4.线程太多会把 CPU、内存打爆
5.分配是即时生效的系统动作
一旦你 new FileInputStream 或 new Socket 成功，就真的占用了 OS 里的一项资源
不管你后面用不用，这个资源都被这次调用“锁住”了，别人用不了
操作系统不会帮你自动“猜”什么时候可以回收

内存可以靠 GC 判断“不再被引用”来回收
文件描述符、连接这些，OS 根本看不到 Java 对象的引用关系，它只看到：
某个进程里，有 N 个打开的 fd/连接，什么时候关我不知道，得你自己系统调用 close()。

结论：
只要你不主动关，它们就一直占着，直到进程结束或系统强制清理。

GC 只管 Java 堆内存：
- 某个对象变成不可达时，GC 只会把它占用的堆内存回收
- 它持有的操作系统资源（文件句柄、socket 等），GC 不负责帮你关闭

很多 I/O 类内部确实会在 finalize() 或其它机制里尝试关闭，但：
- 不可靠：什么时候 GC、什么时候触发，完全不确定
- 可能太晚：文件句柄/连接数耗尽前 GC 没发生，程序直接出错

**资源不释放会存在上面问题？**
1.文件流不关：
- 打开太多文件：抛 Too many open files
- 文件一直被占用：别的程序/线程删不了、改不了

2.数据库连接不关:
- 连接池被用光：后续每个请求都卡住或报“无法获取连接”
- 数据库端资源泄漏

3.Socket 不关:
- 文件描述符泄漏
- 客户端/服务器都认为连接还在，长期占用资源

4.线程池不关：
- 程序想退出时退出不了，因为后台线程还在运行
- 持续占用 CPU / 内存

外部资源生命周期：
FileInputStream 读文件的例子：
~~~text
应用线程                 JVM/JNI          C库/libc                 内核(文件系统)
   |                       |                |                          |
   | new FileInputStream   |                |                          |
   |---------------------->| FileInputStream构造                        |
   |                       | -> native open(path, flags)               |
   |                       |---------------->| open() 系统调用         |
   |                       |                |------------------------->|
   |                       |                |   分配fd, struct file    |
   |                       |                |<-------------------------|
   |                       |<----------------| 返回 fd (如 3)          |
   |                       | 保存到 FileDescriptor                       |
   |                       |                |                          |
   | fis.read()            |                |                          |
   |---------------------->| native read(fd, buf, size)                |
   |                       |---------------->| read(fd, buf, size)     |
   |                       |                |------------------------->|
   |                       |                |  从磁盘/缓存读数据...    |
   |                       |                |<-------------------------|
   |                       |<----------------| 返回读取的字节数         |
   |<----------------------| 拿到数据                                  |
   |                       |                |                          |
   | fis.close()           |                |                          |
   |---------------------->| native close(fd)                           |
   |                       |---------------->| close(fd)               |
   |                       |                |------------------------->|
   |                       |                |  释放 fd、struct file    |
   |                       |                |<-------------------------|
   |                       |<----------------|                          |
   |                       | FileDescriptor 标记为“已关闭”              |
~~~

TCP Socket 连接生命周期(简化 TCP 状态机):
~~~text
客户端应用       JVM/JNI         C库           客户端内核(TCP)        服务器内核(TCP)          服务器应用
   |              |              |                    |                        |                    |
   | new Socket   |              |                    |                        |                    |
   |------------->| native socket()                   |                        |                    |
   |              |------------->| socket() syscall   |                        |                    |
   |              |             |------------------->| 创建socket, 状态: CLOSED-> (等待connect)      |
   |              |<------------| 返回 fd             |                        |                    |
   |              |              |                    |                        |                    |
   | connect()    |              |                    |                        |                    |
   |------------->| native connect(fd, addr)          |                        |                    |
   |              |------------->| connect() syscall  |                        |                    |
   |              |             |------------------->| 发送 SYN, 状态: SYN_SENT -------------------->|
   |              |              |                    |                        | 收到SYN, 状态: SYN_RCVD
   |              |              |                    |<------------------------ 发送 SYN+ACK         |
   |              |              |                    |  收到 SYN+ACK, 状态: ESTABLISHED             |
   |              |              |                    |------------------------> 发送 ACK            |
   |              |              |                    |                        | 状态: ESTABLISHED |
   |              |<------------| connect 返回成功    |                        |                    |
   |<-------------| Socket 准备好                    |                        |                    |
   |              |              |                    |                        |                    |
   | write()/read() 循环使用    |                    |                        |                    |
   |------------->| native send/recv                  |                        |                    |
   |              |------------->| send/recv syscall  |<--------------------->| 应用读写数据        |
   |              |              |                    |                        |                    |
   | close()      |              |                    |                        |                    |
   |------------->| native close(fd)                  |                        |                    |
   |              |------------->| close() syscall    |                        |                    |
   |              |              |------------------->| 发送 FIN, 状态: FIN_WAIT_1 ----------------->|
   |              |              |                    |                        | 收到FIN, 状态: CLOSE_WAIT
   |              |              |                    |<------------------------ 发送 ACK             |
   |              |              |                    | 状态: FIN_WAIT_2                            |
   |              |              |                    |<------------------------ 服务器发送 FIN      |
   |              |              |                    | 发送 ACK, 状态: TIME_WAIT                   |
   |              |              |                    | 定时器到期后 -> CLOSED                      |
   |              |<------------| close 返回          |                        |                    |
   |<-------------| Java Socket 标记为已关闭          |                        | 服务器应用关闭socket |
~~~

数据库连接生命周期(以 JDBC + 关系型数据库为例):
~~~text
应用线程           JDBC驱动(JVM)        本地DB客户端库          网络+协议         DB服务器(会话)
   |                |                    |                        |                    |
   | getConnection  |                    |                        |                    |
   |--------------->| 解析 URL、参数                              |                    |
   |                | 建立 Socket (见 TCP 流程)                   |------------------>|
   |                |------------------->| 发送握手/登录协议                          |
   |                |                    |----------------------->| 创建 session、分配资源
   |                |                    |<-----------------------| 返回握手/登录成功 |
   |                |<-------------------| 建立 JDBC Connection 对象                 |
   |<---------------| 返回 Connection                             |                    |
   |                |                    |                        |                    |
   | prepareStatement/executeQuery       |                        |                    |
   |------------------------------------>| 组装 SQL, 发送请求    |------------------->|
   |                |                    |                        | 解析SQL、执行、返回结果
   |                |                    |<-----------------------| 结果集数据         |
   |<------------------------------------| JDBC 包装为 ResultSet                       |
   | 遍历 ResultSet |                    |                        |                    |
   |                |                    |                        |                    |
   | conn.close()   |                    |                        |                    |
   |--------------->| 标记 Connection 关闭                         |                    |
   |                |------------------->| 发送“结束会话/断开”协议 |------------------>|
   |                |                    |                        | 释放 session资源   |
   |                |                    | 关闭底层 Socket        |<------------------|
   |                |<-------------------|                        |                    |
   |<---------------| Connection.close 返回                        |                    |
~~~

线程生命周期(Java 线程 + OS 线程):
~~~text
主线程          JVM            本地线程库       内核(调度)            新线程(执行体)
  |             |                 |                |                      |
  | new Thread  | 创建 Thread对象 |                |                      |
  |------------>| Thread.state: NEW                                    |
  |             |                 |                |                      |
  | start()     |                 |                |                      |
  |------------>| 分配本地结构, 调用 pthread_create / CreateThread      |
  |             |---------------->| 创建 OS 线程                        |
  |             |                 |---------------->| 分配TCB/栈, 就绪    |
  |             |                 |                | 调度运行            |
  |             |                 |                |-------------------->|
  |             |                 |                | 进入 run() 方法     |
  |             |                 |                | 反复执行任务        |
  |             |                 |                | run() 返回          |
  |             |                 |<----------------| 线程结束, 资源待回收|
  |             | JVM观测: Thread.state: TERMINATED                      |
  |             |                 |                |                      |
  | join()      |                 |                |                      |
  |------------>| 等待OS线程结束  |                |                      |
  |             |<----------------| 回收线程资源完成                      |
  |<------------| join返回        |                |                      |
~~~