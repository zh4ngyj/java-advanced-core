# 模块: JMM (Java Memory Model)

Java 内存模型 (JMM) 是一个抽象的概念，它定义了 Java 程序中各种变量（实例字段、静态字段和构成数组对象的元素）的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

## 核心目标
JMM 旨在屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台上都能达到一致的内存访问效果。

## 三大特性

JMM 围绕并发过程中如何处理原子性、可见性和有序性这三个特征来建立。

### 1. 原子性 (Atomicity)
- **定义**: 一个或多个操作，要么全部执行且执行的过程不会被任何因素打断，要么就都不执行。
- **Java 实现**:
    - 基本数据类型的读写操作是原子的（`long` 和 `double` 除外，它们在 32 位系统上可能被拆分为两次操作，但可以使用 `volatile` 保证其原子性）。
    - `synchronized` 块之间的操作是原子的。
    - `java.util.concurrent.atomic` 包中的原子类提供了原子操作。

### 2. 可见性 (Visibility)
- **定义**: 当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。
- **原因**: 每个线程都有自己的工作内存（高速缓存），线程对变量的操作都在工作内存中进行，然后才同步到主内存。这可能导致一个线程的修改对另一个线程不可见。
- **Java 实现**:
    - `volatile`: 保证了对变量的修改会立即同步到主内存，并且每次读取前都会从主内存刷新。
    - `synchronized`: 在 `unlock` 之前，必须把变量同步回主内存。
    - `final`: 被 `final` 修饰的字段在构造器中一旦初始化完成，并且构造器没有把 `this` 引用传递出去，那么在其他线程中就能看见 `final` 字段的值。

### 3. 有序性 (Ordering)
- **定义**: 程序执行的顺序按照代码的先后顺序执行。
- **原因**: 为了提高性能，编译器和处理器可能会对指令进行重排序 (Reordering)。
- **Java 实现**:
    - `volatile`: 禁止指令重排序。
    - `synchronized`: 一个变量在同一个锁中一次只能被一个线程操作，保证了持有同一个锁的两个同步块只能串行地进入，从而保证了有序性。

## `happens-before` 原则

JMM 定义了 `happens-before` 原则，用于判断数据是否存在竞争、线程是否安全。如果两个操作之间存在 `happens-before` 关系，那么前一个操作的结果将对后一个操作可见。

1.  **程序次序规则**: 在一个线程内，代码顺序在前的操作 `happens-before` 于代码顺序在后的操作。
2.  **管程锁定规则**: 一个 `unlock` 操作 `happens-before` 于后面对同一个锁的 `lock` 操作。
3.  **`volatile` 变量规则**: 对一个 `volatile` 变量的写操作 `happens-before` 于后面对这个变量的读操作。
4.  **线程启动规则**: `Thread` 对象的 `start()` 方法 `happens-before` 于此线程的每一个动作。
5.  **线程终止规则**: 线程中的所有操作都 `happens-before` 于对此线程的终止检测。
6.  **传递性**: 如果 A `happens-before` B，且 B `happens-before` C，那么 A `happens-before` C。