# 模块: JVM 垃圾回收 (Garbage Collection)

垃圾回收 (GC) 是 Java 语言的一大特性，它自动管理内存，使开发者无需手动释放对象。

## 1. 如何判断对象已死？

### a. 引用计数法 (Reference Counting)
- **原理**: 给对象添加一个引用计数器，每当有一个地方引用它，计数器加 1；引用失效时，计数器减 1。任何时刻计数器为 0 的对象就是不可能再被使用的。
- **缺点**: 实现简单，但难以解决对象之间**循环引用**的问题。**JVM 并未使用此方法**。

### b. 可达性分析算法 (Reachability Analysis)
- **原理**: 通过一系列称为 "GC Roots" 的根对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到任何 GC Roots 都没有引用链相连时，则证明此对象是不可用的。
- **GC Roots 对象**:
    - 虚拟机栈中引用的对象。
    - 方法区中类静态属性引用的对象。
    - 方法区中常量引用的对象。
    - 本地方法栈中 JNI 引用的对象。

## 2. 垃圾收集算法

### a. 标记-清除 (Mark-Sweep)
- **过程**:
    1. **标记**: 标记出所有需要回收的对象。
    2. **清除**: 清除所有被标记的对象。
- **缺点**:
    - **效率问题**: 标记和清除两个过程的效率都不高。
    - **空间问题**: 产生大量不连续的内存碎片。

### b. 标记-复制 (Mark-Copy)
- **过程**: 将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
- **优点**: 实现简单，运行高效，不产生内存碎片。
- **缺点**: 将内存缩小为了原来的一半，代价高昂。
- **应用**: 主要用于**新生代**。新生代中的对象存活率较低，所以只需复制少量存活对象即可。

### c. 标记-整理 (Mark-Compact)
- **过程**:
    1. **标记**: 与“标记-清除”一样。
    2. **整理**: 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
- **优点**: 解决了内存碎片问题。
- **应用**: 主要用于**老年代**。

## 3. 分代收集理论 (Generational Collection)

- **核心**: 根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为**新生代 (Young Generation)**和**老年代 (Old Generation)**。
- **新生代**:
    - 绝大多数对象都是“朝生夕死”的，所以每次垃圾回收时都有大量对象被回收。
    - 使用**标记-复制**算法。
    - 进一步划分为一个 Eden 区和两个 Survivor 区 (From/To)。
- **老年代**:
    - 对象存活率高、没有额外空间对它进行分配担保。
    - 使用**标记-清除**或**标记-整理**算法。

## 4. 垃圾收集器

- **Serial**: 单线程收集器，进行垃圾回收时，必须暂停所有其他工作线程 (Stop The World)。
- **Parallel Scavenge**: 新生代收集器，使用复制算法，是并行的多线程收集器。关注**吞吐量**。
- **CMS (Concurrent Mark Sweep)**: 老年代收集器，以获取**最短回收停顿时间**为目标。基于“标记-清除”算法，过程复杂（初始标记、并发标记、重新标记、并发清除）。
- **G1 (Garbage-First)**: 横跨新生代和老年代。将整个堆划分为多个大小相等的独立区域 (Region)，跟踪各个 Region 里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。
- **ZGC / Shenandoah**: JDK 11+ 引入的低延迟垃圾收集器，停顿时间可以控制在毫秒级别。