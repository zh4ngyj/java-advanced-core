# 设计模式: 模板方法模式 (Template Method)

模板方法模式是一种行为设计模式，它在一个方法中定义一个算法的骨架，而将一些步骤的实现延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些特定步骤。

## 核心思想
将算法中不变的部分封装在父类中，将可变的部分由子类来实现。这是一种基于**继承**的代码复用技术。

## 角色
1.  **抽象类 (Abstract Class)**:
    - 定义一个或多个**抽象方法**，这些是算法中可变的部分，由子类实现。
    - 定义一个**模板方法** (`templateMethod()`)，该方法是 `final` 的，它定义了算法的骨架，并按照特定的顺序调用抽象方法和具体方法。
    - (可选) 定义**钩子方法 (Hook Methods)**，这些是父类中具有默认实现的空方法或普通方法，子类可以选择性地覆盖它们以“钩入”算法的特定步骤。

2.  **具体类 (Concrete Class)**:
    - 继承抽象类。
    - 实现父类中定义的抽象方法，以完成算法中与自身相关的步骤。
    - (可选) 覆盖钩子方法，以调整算法的行为。

## 优缺点

### 优点
- **代码复用**: 将算法的公共部分提取到父类中，提高了代码复用性。
- **封装不变部分，扩展可变部分**: 将算法的核心逻辑固定在父类的模板方法中，防止被子类修改，同时通过抽象方法和钩子方法提供了良好的扩展点。
- **行为控制**: 父类通过模板方法控制了子类的行为，子类必须遵循算法的骨架。

### 缺点
- **继承带来的限制**: 由于该模式基于继承，每个不同的实现都需要一个单独的子类，可能导致类的数量增加。同时，子类与父类的耦合度较高。

## 经典应用
- **`java.io.InputStream`**: `read()` 方法是一个模板方法，它调用了子类必须实现的 `read()` 抽象方法。
- **`java.util.AbstractList`**: 提供了 `List` 接口的骨架实现，许多方法（如 `add`, `remove`）都依赖于子类对 `get(int)` 和 `size()` 等核心方法的实现。
- **JUnit 单元测试框架**: `setUp()` 和 `tearDown()` 方法就是钩子方法，它们在核心的测试方法执行前后被调用。