# 设计模式: 策略模式 (Strategy)

策略模式是一种行为设计模式，它定义了一系列算法，将每个算法封装起来，并使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户端。

## 核心思想
当一个操作有多种不同的实现方式，与其在代码中使用大量的 `if-else` 或 `switch` 语句来选择，不如将这些实现方式（策略）抽象成独立的类，让客户端可以在运行时动态地选择和切换。

## 角色
1.  **上下文 (Context)**:
    - 维护一个对策略对象 (`Strategy`) 的引用。
    - 不直接执行算法，而是将工作委托给其持有的策略对象。
    - 客户端通过它来配置和使用具体的策略。

2.  **策略接口 (Strategy)**:
    - 定义了所有支持的算法的公共接口。
    - 上下文 (Context) 使用这个接口来调用由具体策略 (ConcreteStrategy) 实现的算法。

3.  **具体策略 (Concrete Strategy)**:
    - 实现了策略接口，提供了算法的具体实现。
    - 每个具体策略类都代表一种算法。

## 优缺点

### 优点
- **符合开闭原则**: 可以轻松地增加新的策略，而无需修改上下文或其他现有策略的代码。
- **消除 `if-else` / `switch`**: 避免了多重条件判断，使代码更清晰、更易于维护。
- **算法的独立性**: 每个算法都封装在自己的类中，易于理解、测试和复用。
- **运行时切换**: 客户端可以在运行时动态改变对象的行为（算法）。

### 缺点
- **类数量增多**: 每个策略都需要一个单独的类，可能会导致项目中类的数量增加。
- **客户端必须了解策略**: 客户端需要知道有哪些不同的策略，并自行决定使用哪一个，这增加了一定的复杂性。

## 经典应用
- **`java.util.Comparator`**: 在 `Collections.sort()` 或 `Arrays.sort()` 中传入不同的 `Comparator` 对象，就是一种典型的策略模式应用，用于定义不同的排序策略。
- **支付系统**: 选择不同的支付方式（信用卡、PayPal、支付宝等），每种支付方式是一种策略。本包中的 `StrategyPatternDemo.java` 就是一个例子。