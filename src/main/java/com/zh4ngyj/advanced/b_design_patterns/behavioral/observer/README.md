# 设计模式: 观察者模式 (Observer)

观察者模式是一种行为设计模式，它定义了对象之间的一种一对多（One-to-Many）的依赖关系，当一个对象（主题）的状态发生改变时，所有依赖于它的对象（观察者）都会得到通知并自动更新。它也被称为**发布-订阅 (Publish-Subscribe)**模式。

## 核心思想
实现主题与观察者之间的松耦合。主题只知道它有一系列观察者，但不需要知道这些观察者是谁、是什么类型。当状态改变时，它只需广播通知，由观察者自己决定如何响应。

## 角色
1.  **主题 (Subject / Observable)**:
    - 维护一个观察者列表。
    - 提供用于添加 (`register`)、删除 (`unregister`) 和通知 (`notify`) 观察者的方法。
    - 持有状态，当状态改变时，会通知所有注册的观察者。

2.  **具体主题 (Concrete Subject)**:
    - 实现了主题接口。
    - 当其内部状态发生改变时，会向所有已注册的观察者发送通知。

3.  **观察者 (Observer)**:
    - 定义了一个更新接口（通常是 `update()` 方法），当接收到主题的通知时，该方法被调用。

4.  **具体观察者 (Concrete Observer)**:
    - 实现了观察者接口。
    - 在接收到更新通知后，执行具体的操作。
    - 在创建时需要将自己注册到具体主题中。

## 推 (Push) 模型 vs. 拉 (Pull) 模型

- **推模型**: 主题在通知观察者时，主动将改变后的数据（或所有数据）推送给观察者。观察者是被动接收。
- **拉模型**: 主题只通知观察者“状态已改变”，由观察者自己决定是否需要以及需要哪些数据，并主动从主题中拉取。

拉模型通常被认为更好，因为它给予观察者更多的灵活性。

## 经典应用
- **图形用户界面 (GUI)**: Swing 和 AWT 中的事件监听器机制（如 `ActionListener`）是观察者模式的典型应用。按钮是主题，监听器是观察者。
- **消息队列 (Message Queue)**: 发布者-订阅者模型是观察者模式的一种变体。
- **模型-视图-控制器 (MVC) 架构**: 模型 (Model) 作为主题，视图 (View) 作为观察者。当模型数据变化时，会通知所有相关的视图进行更新。
- **`java.util.Observable` 和 `java.util.Observer`**: 这是 Java 早期提供的观察者模式实现，但由于其设计上的缺陷（`Observable` 是类而不是接口，限制了继承），在 Java 9 中已被标记为**废弃 (deprecated)**。推荐开发者根据需要自行实现。