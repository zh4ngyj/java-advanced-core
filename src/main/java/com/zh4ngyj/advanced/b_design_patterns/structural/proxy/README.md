# 设计模式: 代理模式 (Proxy)

代理模式是一种结构型模式，它为其他对象提供一种代理以控制对这个对象的访问。

## 核心思想
在不改变原始对象（被代理对象）的基础上，通过引入代理对象来为原始对象添加额外的功能或控制。

## 应用场景
- **远程代理 (Remote Proxy)**: 为一个位于不同地址空间的对象提供一个本地的代表。
- **虚拟代理 (Virtual Proxy)**: 根据需要创建开销大的对象。
- **保护代理 (Protection Proxy)**: 控制对原始对象的访问权限。
- **智能引用 (Smart Reference)**: 在访问对象时执行一些附加操作，如引用计数。

## 实现方式

### 1. 静态代理
- **定义**: 代理类和被代理类在编译时就已经确定。代理类和被代理类实现同一个接口，或者代理类继承被代理类。
- **优点**: 实现简单。
- **缺点**:
    - **代码冗余**: 每个被代理的类都需要创建一个对应的代理类。
    - **不易维护**: 如果接口增加方法，被代理类和代理类都需要修改。

### 2. 动态代理
- **定义**: 代理类在程序运行时动态创建。它不需要为每个被代理类都创建一个代理类。

#### a. JDK 动态代理
- **核心**: `java.lang.reflect.Proxy` 类和 `java.lang.reflect.InvocationHandler` 接口。
- **原理**: 基于**接口**实现。通过 `Proxy.newProxyInstance()` 方法，动态地创建一个实现了指定接口的代理类实例。对代理实例的所有方法调用都会被转发到 `InvocationHandler` 的 `invoke()` 方法中。
- **限制**: 被代理的类必须实现至少一个接口。

#### b. CGLIB 动态代理
- **核心**: 基于 `ASM` 字节码操作库。
- **原理**: 基于**继承**实现。它通过动态生成一个被代理类的子类来作为代理类，并重写父类的非 `final` 方法。
- **优点**: 即使被代理类没有实现接口，也可以为其创建代理。
- **限制**: 不能代理 `final` 方法或 `final` 类。
- **应用**: Spring AOP 在代理目标是类时，会使用 CGLIB。