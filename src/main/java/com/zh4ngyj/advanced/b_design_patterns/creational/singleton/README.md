# 设计模式: 单例模式 (Singleton)

单例模式是一种创建型模式，确保一个类只有一个实例，并提供一个全局访问点来获取这个实例。

## 核心思想
1.  **私有化构造函数**: 防止外部通过 `new` 关键字直接创建多个实例。
2.  **静态实例**: 在类的内部创建一个私有的静态实例。
3.  **公共静态方法**: 提供一个 `public static` 方法作为全局访问点，返回内部创建的唯一实例。

---

## 常见实现方式

### 1. 饿汉式 (Eager Initialization)
- **实现**: 在类加载时就立即创建实例。
- **优点**:
    - 实现简单。
    - **线程安全**: JVM保证了类加载过程的线程安全性。
- **缺点**:
    - **资源浪费**: 如果实例从未使用过，会造成内存浪费。
- **示例**: `EagerSingleton.java`

### 2. 懒汉式 (Lazy Initialization)
- **实现**: 在第一次调用 `getInstance()` 方法时才创建实例。
- **优点**: 延迟加载，节省资源。
- **缺点**:
    - **线程不安全**: 在多线程环境下，可能导致创建多个实例。需要通过加锁来解决。
- **示例**: `LazySingleton.java` (线程不安全的版本)

### 3. 双重检查锁 (Double-Checked Locking, DCL)
- **实现**: 懒汉式的线程安全优化版本。通过两次 `null` 检查和 `synchronized` 块来保证线程安全和高性能。
- **优点**:
    - 线程安全。
    - 延迟加载。
    - 性能较高：只有在实例未创建时才会进入同步块。
- **注意事项**:
    - 必须使用 `volatile` 关键字修饰实例变量，以防止指令重排序问题。在 `new DCLSingleton()` 时，这个操作不是原子的，可能分为：1.分配内存；2.初始化对象；3.将引用指向内存地址。如果没有 `volatile`，指令重排可能导致线程拿到一个未完全初始化的对象。
- **示例**: `DCLSingleton.java`

### 4. 静态内部类 (Static Inner Class)
- **实现**: 利用JVM类加载机制来保证线程安全。实例在静态内部类中创建，只有当 `getInstance()` 被调用时，静态内部类才会被加载，从而创建实例。
- **优点**:
    - **线程安全**: 由JVM保证。
    - **延迟加载**: 只有在需要时才创建实例。
    - 实现简单，代码优雅。
- **这是最推荐的实现方式之一。**
- **示例**: `StaticInnerClassSingleton.java`

### 5. 枚举 (Enum)
- **实现**: 使用 `enum` 关键字定义。
- **优点**:
    - **最简洁的实现**。
    - **绝对线程安全**: 由JVM从语法层面保证。
    - **防止反序列化创建新实例**: 枚举的序列化机制可以从根本上杜绝反序列化创建新对象的问题。
- **缺点**:
    - 不支持懒加载。
    - 可读性相对较差，不熟悉的人可能不理解其原理。
- **《Effective Java》作者 Joshua Bloch 强烈推荐的方式。**
- **示例**: `EnumSingleton.java`

---

## 防止破坏单例的手段
- **防止反射攻击**: 在私有构造函数中，如果实例已经存在，直接抛出异常。
- **防止序列化攻击**: 在单例类中实现 `readResolve()` 方法，在该方法中直接返回已存在的实例。枚举方式天生可以防止此问题。